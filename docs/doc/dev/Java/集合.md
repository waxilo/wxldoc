## ArrayList

数据结构：Object数组

### 扩容机制

1. 当 `size + 1 > capacity` 时，触发`grow`扩容。
2. 空数组扩容为10，非空数组1.5倍扩容
```java
	// 1.5 倍扩容
	int newCapacity = oldCapacity + (oldCapacity >> 1); 
	
	// 数据拷贝，底层实现是System.arraycopy
	elementData = Arrays.copyOf(elementData, newCapacity); 
```

## HashMap

数据结构：HashTable + 链表\红黑树

### 多线程问题

#### 1. **数据不一致（脏读/丢失更新）**

- 多个线程同时执行 `put()` 或 `remove()` 操作时，由于没有同步机制，可能导致：
    - 某些写入操作被覆盖或丢失；
    - 读取到中间状态的数据（例如部分更新的值）。

#### 2. **死循环（JDK 7 及更早版本中特别严重）**

- 在 JDK 7 及之前的 `HashMap` 实现中，当发生哈希冲突时使用**链表**存储元素。
- 在扩容（resize）过程中，会将链表**反转**。如果多个线程同时触发扩容，可能造成链表**成环**（形成循环引用）。
- 后续对该 `HashMap` 的 `get()` 操作会陷入**无限循环**，导致 CPU 占用 100%，程序卡死。

> ⚠️ 虽然 JDK 8 改进了扩容逻辑（使用尾插法避免成环），**但仍然不是线程安全的**，仍可能出现数据错乱等问题。

#### 3. **size 统计错误**

- `HashMap` 内部维护一个 `size` 字段记录元素数量。
- 多线程并发 `put` 时，`size++` 不是原子操作，可能导致最终 `size()` 返回错误的值。

#### 4. **空指针异常（NullPointerException）**

- 在某些竞态条件下，可能读取到尚未完全初始化的桶（bucket）或节点，导致 NPE。

## LinkedHashMap

数据结构：HashMap + 双向链表

## CopyOnWriteArrayList

数据结构：Object数组

### 写操作

1. 获取写锁，每次仅允许一个写请求，阻塞其他。
2. 复制数组副本，在副本上进行写操作。
3. `volatile`的引用覆盖操作，将副本覆盖原引用。

## ConcurrentHashMap

数据结构：HashTable + 链表/红黑树 + Node锁

## PriorityQueue

数据结构：数组维护的堆