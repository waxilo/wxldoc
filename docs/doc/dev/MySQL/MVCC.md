在没有MVCC的数据库中：
- 读操作可能被写操作阻塞（需等写锁释放）
- 写操作也可能被读操作阻塞（如加共享锁）

而 MVCC 通过 **“读不加锁 + 快照读”** 实现：
- **普通 SELECT（快照读）**：不加锁，直接读取历史版本数据
- **当前读（如 `SELECT ... FOR UPDATE`）**：加锁，读取最新数据

## 核心组成

### 隐藏字段

| 字段                | 大小   | 说明                                           | 是否总是存在          |
| ----------------- | ---- | -------------------------------------------- | --------------- |
| **`DB_ROW_ID`**   | 6 字节 | 行 ID，用于生成聚簇索引（当表没有主键或唯一非空索引时）                | ❌ 有条件存在         |
| **`DB_TRX_ID`**   | 6 字节 | 最近一次插入或更新该行的**事务 ID**                        | ✅ 总是存在（只要启用了事务） |
| **`DB_ROLL_PTR`** | 7 字节 | 回滚指针（Rollback Pointer），指向该行的 **Undo Log 记录** | ✅ 总是存在（只要启用了事务） |

### 回滚日志

- 每次对数据进行 `INSERT`/`UPDATE`/`DELETE` 时，InnoDB 会将**旧版本数据**写入 Undo Log。
- Undo Log 形成一个**版本链（Version Chain）**，从最新记录通过 `DB_ROLL_PTR` 一路回溯到最初版本。
```
当前行 (trx_id=105) 
	↓ (roll_ptr) 
旧版本 (trx_id=102) 
	↓ (roll_ptr) 
更旧版本 (trx_id=98) 
	↓ ...
```

### 读视图（Read View）

#### 创建时机

| 隔离级别                 | Read View 创建时机                   | 特点                      |
| -------------------- | -------------------------------- | ----------------------- |
| READ COMMITTED (RC)  | 每次 SELECT 都创建新的 Read View        | 总能读到其他事务已提交的最新数据（不可重复读） |
| REPEATABLE READ (RR) | 事务中第一次 SELECT 时创建 Read View，后续复用 | 保证可重复读，解决幻读（配合间隙锁）      |

#### 包含的关键信息

- `m_ids`：当前**活跃事务 ID 列表**（未提交的事务）
- `min_trx_id`：`m_ids` 中的最小事务 ID
- `max_trx_id`：下一个将要分配的事务 ID（即当前最大已分配 ID + 1）
- `creator_trx_id`：创建该 Read View 的事务 ID（若当前事务是只读，则为 0）

#### 可见性判断规则
当事务 A 执行 `SELECT` 时，对某一行的多个版本，按以下规则判断是否可见：
假设当前行版本的 `trx_id = X`，Read View 为 `RV`：

| 条件                                    | 是否可见  | 说明                              |
| ------------------------------------- | ----- | ------------------------------- |
| 1. `X == RV.creator_trx_id`           | ✅ 可见  | 自己修改的数据，当然可见（即使未提交）             |
| 2. `X < RV.min_trx_id`                | ✅ 可见  | 该版本在 Read View 创建前已提交           |
| 3. `X >= RV.max_trx_id`               | ❌ 不可见 | 该版本在 Read View 创建后才开启，属于“未来”事务  |
| 4. `X ∈ RV.m_ids`                     | ❌ 不可见 | 该版本由未提交的活跃事务创建，不可见              |
| 5. `X < RV.max_trx_id 且 X ∉ RV.m_ids` | ✅ 可见  | 该版本已提交（虽在 Read View 创建后开启，但已提交） |

🔁 如果当前版本不可见，则沿着 `DB_ROLL_PTR` 找上一个版本，重复判断，直到找到可见版本或遍历完。

#### MVCC 的局限性

1. **不能替代锁**：
    - `SELECT ... FOR UPDATE` / `LOCK IN SHARE MODE` 是**当前读**，会加锁，不走 MVCC。
2. **Undo Log 需要清理**：
    - 长时间运行的事务会阻止 Purge 线程清理旧版本，导致 Undo Log 膨胀（“长事务危害”）。
3. **不解决所有幻读**：
    - RR 下通过 **MVCC + 间隙锁（Gap Lock）** 共同解决幻读。