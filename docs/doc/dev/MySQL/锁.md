## 一、锁的分类（按作用范围）

### 1. **行级锁（Row-Level Locking）** （InnoDB 默认）

- 锁定**单行记录**，并发度高。
- 适用于高并发 OLTP 场景。
- 实现方式：基于 **索引** 加锁（无索引会退化为表锁！）。

### 2. **表级锁（Table-Level Locking）**

- 锁定整张表，开销小但并发低。
- MyISAM 只支持表锁；InnoDB 在某些场景下也会用（如 DDL、无索引的 `UPDATE`）。

## 二、InnoDB 的核心锁类型（按功能）

### 1. **共享锁（Shared Lock, S 锁）**

- 又称 **读锁（Read Lock）**
- 多个事务可同时持有 S 锁
- 兼容性：S 与 S 兼容，S 与 X **不兼容**
```sql
-- 显式加 S 锁 
SELECT ... LOCK IN SHARE MODE; -- MySQL 5.7 及之前 
SELECT ... FOR SHARE; -- MySQL 8.0+
```

### 2. **排他锁（Exclusive Lock, X 锁）**

- 又称 **写锁（Write Lock）**
- 仅允许一个事务持有 X 锁
- 兼容性：X 与 S/X 均**不兼容**
```sql
-- 显式加 X 锁 
SELECT ... FOR UPDATE; 
-- 或 UPDATE / DELETE 自动加 X 锁`
```

### 3. **意向锁（Intention Locks）** —— 表级“预告”锁

- **目的**：快速判断表中是否有行被锁定，避免逐行检查。
- 是 **表级锁**，由 InnoDB 自动管理，用户不可见。

|意向锁类型|含义|与表锁兼容性|
|---|---|---|
|IS（Intention Shared）|表示事务打算对某些行加 S 锁|与表 S 锁兼容，与表 X 锁冲突|
|IX（Intention Exclusive）|表示事务打算对某些行加 X 锁|与表 S/X 锁均冲突|

举例：
- 执行 `SELECT ... FOR UPDATE` 时，InnoDB 自动先加 **IX 锁（表级）**，再加 **X 锁（行级）**。
- 若另一事务想加 **表级 X 锁（如 ALTER TABLE）**，发现已有 IX 锁 → 直接阻塞，无需检查每行。

## 三、InnoDB 的高级锁

### **1. 记录锁（Record Lock）**

- 锁定**索引记录本身**（即某一行）。
- 例如：`WHERE id = 10`（id 为主键）→ 锁住 id=10 的行。
  
### **2. 间隙锁（Gap Lock）**

- 锁定**索引记录之间的“间隙”**，**不包括记录本身**。
- **目的**：防止其他事务在间隙中插入新数据，从而避免**幻读（Phantom Read）**。
- 仅在 **REPEATABLE READ（RR）** 隔离级别下启用（RC 下关闭）。
```sql
-- 假设 id 有索引，值为 10, 20, 30 
SELECT * FROM t WHERE id > 15 AND id < 25 FOR UPDATE;
```

### **3. 临键锁（Next-Key Lock）** （InnoDB 默认行锁）

- **记录锁（Record Lock） + 间隙锁（Gap Lock）**
- 锁住 **“记录 + 左侧间隙”**
- 是 InnoDB 在 RR 隔离级别下**防止幻读的核心机制**
  
## 加锁时机

| 操作类型               | 是否加锁  | 说明                                                                                                                      |
| ------------------ | ----- | ----------------------------------------------------------------------------------------------------------------------- |
| 快照读（Snapshot Read） | ❌ 不加锁 | 普通 `SELECT`，走 MVCC，读历史版本                                                                                                |
| 当前读（Current Read）  | ✅ 加锁  | 读取最新数据，并加锁：  <br>• `SELECT ... FOR UPDATE`  <br>• `SELECT ... LOCK IN SHARE MODE`  <br>• `UPDATE` / `DELETE` / `INSERT` |


## MySQL的死锁问题

死锁发生需同时满足以下四个条件（Coffman 条件）：

1. **互斥**：资源不能被共享（如行锁）
2. **持有并等待**：事务持有锁的同时请求其他锁
3. **不可剥夺**：已分配的锁不能被强制释放
4. **循环等待**：事务形成环形依赖（A 等 B，B 等 A）
   
>  InnoDB 的死锁几乎都源于 **多个事务以不同顺序操作同一组数据行**。

### 示例

```sql
-- 事务 A 
BEGIN; 
UPDATE users SET balance = balance - 100 WHERE id = 1; -- 锁住 id=1 
UPDATE users SET balance = balance + 100 WHERE id = 2; -- 尝试锁 id=2 

-- 事务 B（同时执行） 
BEGIN; 
UPDATE users SET balance = balance - 50 WHERE id = 2; -- 锁住 id=2 
UPDATE users SET balance = balance + 50 WHERE id = 1; -- 尝试锁 id=1 → 死锁！
```

### 如何定位

1. 开启死锁日志（MySQL 5.6.2+），在 `my.cnf` 中配置：``innodb_print_all_deadlocks = ON``
2. 执行：``SHOW ENGINE INNODB STATUS\G``，在输出中找到 **`LATEST DETECTED DEADLOCK`** 部分，包含：
	- 两个死锁事务的 ID
	- 各自已持有的锁（`HOLDS THE LOCK(S)`）
	- 各自正在等待的锁（`WAITING FOR THIS LOCK TO BE GRANTED`）
	- 被回滚的事务（`WE ROLL BACK TRANSACTION`）


### 如何解决

| 策略         | 详解                                                                      |
| ---------- | ----------------------------------------------------------------------- |
| 统一访问顺序     | 所有事务**按相同顺序操作数据**（如 always update user_id 小的先），能彻底避免循环等待，是**最有效的预防手段**。 |
| 减少事务粒度     | - **尽快提交事务**，不要在事务中做网络调用、用户交互、复杂计算。                                     |
| 避免大范围更新、删除 | 若匹配百万行，会锁大量记录，极易死锁，改为**分批次处理**。                                         |
| 合理使用索引     | - **无索引的 WHERE 条件会导致全表扫描 + 锁全表**，极大增加死锁概率。                              |
