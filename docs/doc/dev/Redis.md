## 5种基本数据结构

### String（字符串）

String 是 Redis 中最基本的数据类型，其值可以是字符串、整数或浮点数，且最大容量为 512MB。它是二进制安全的，意味着可以存储任何数据（如文本、图片序列化数据等）。String 支持原子操作，例如自增（`INCR`）和自减（`DECR`），适用于计数场景。

String 类型的底层编码会根据存储值的类型和长度自动选择，主要有三种实现方式：

**int 编码**：当存储的字符串值可以表示为长整型（long）时，Redis 会直接使用整数存储，以节省内存

**embstr 编码**：当存储的字符串长度**小于等于44字节**时，Redis 会使用 `embstr`格式的 SDS（Simple Dynamic String）。这种编码将 RedisObject 对象和 SDS 结构在内存中连续分配，创建和释放效率更高。

**raw 编码**：当存储的字符串长度**大于44字节**时，则使用 `raw`格式的 SDS。需要注意的是，任何对 `embstr`编码字符串的修改操作，都会使其先转换为 `raw`编码，无论修改后的长度是否超过44字节。

### List（列表）

List 是一个双向链表结构，元素有序且可重复。支持从头部（左）或尾部（右）插入和弹出元素，操作时间复杂度为 O(1)。

**历史实现（Redis 3.2之前）**：List 的底层结构可以是 `ziplist`（压缩列表）或 `linkedlist`（双向链表）。当列表同时满足以下两个条件时，使用 `ziplist`，否则使用 `linkedlist`。

- 列表保存的**所有字符串元素的长度都小于64字节**。
- 列表保存的**元素数量少于512个**。

**当前实现（Redis 3.2及之后）**：统一采用 **`quicklist`**（快速列表）。`quicklist`是多个 `ziplist`通过双向链表连接而成的结构，结合了 `ziplist`的内存紧凑优势和 `linkedlist`的节点修改效率。

在 Redis 7.0 中，`quicklist`中的 `ziplist`节点被 `listpack`数据结构所取代，以解决 `ziplist`在极端情况下可能引发的连锁更新问题

### Hash（哈希）

Hash 是一个键值对集合，适用于存储对象（如用户信息）。每个 Hash 可以存储多达 40 多亿个键值对。

Hash 类型使用两种编码，转换条件基于存储的键值对数量和大小：

**ziplist / listpack 编码**：在 Redis 7.0 之前使用 `ziplist`，7.0 之后由 `listpack`实现。当同时满足以下两个条件时，采用此编码

- 哈希对象保存的**所有键值对的键和值的字符串长度都小于64字节**。
- 哈希对象保存的**键值对的数量小于512个**。

**hashtable 编码**：当无法同时满足上述两个条件时，编码会转换为 `hashtable`（哈希表），以保证在大数据量下的高效查询。需要注意的是，一旦转换为 `hashtable`，即使数据量减少，也不会再转回 `ziplist`或 `listpack`。

### Set（集合）

Set 是无序且不重复的字符串集合。支持交集、并集、差集等集合运算。

Set 类型的编码转换取决于元素的内容和数量：

**intset 编码**：当集合同时满足以下两个条件时，使用整数集合存储：

- 集合对象保存的**所有元素都是整数值**。
- 集合对象保存的**元素数量不超过512个**。

**hashtable 编码**：如果集合中的元素不全是整数，或者元素数量超过512个，则使用 `hashtable`编码。此时，集合的每个元素作为字典的键，值则统一为 `NULL`。

### Zset（有序集合）

Zset 是 Set 的扩展，每个元素关联一个分数（score），按分数排序。元素唯一但分数可重复。

Zset 类型的底层结构转换条件如下：

**ziplist / listpack 编码**：在 Redis 7.0 之前使用 `ziplist`，7.0 之后由 `listpack`实现。当同时满足以下两个条件时，采用此编码：

- 有序集合保存的**元素数量小于128个**。
- 有序集合保存的**所有元素的成员（member）长度都小于64字节**。

**skiplist + hashtable 编码**：当上述任一条件不满足时，则转换为组合编码。跳跃表（SkipList）负责按分值（score）维护元素的有序性，支持高效的范围查询；而哈希表（HashTable）则用于提供元素到分值的 O(1) 复杂度查找。

## 底层数据结构

### SDS（简单动态字符串）

SDS是Redis为替代C语言原生字符串而自行实现的字符串结构，它是二进制安全的，可以存储任何数据

**结构设计**：一个SDS结构体包含三个关键字段：`len`记录已使用的字节数、`alloc`记录分配的总容量、`buf`字节数组用于保存实际字符串数据。通过在结构头中记录长度，SDS可以在O(1)时间复杂度内获取字符串长度，而C字符串需要O(N)的遍历。

**核心优势**：

- **杜绝缓冲区溢出**：在修改字符串前，SDS会检查剩余空间（`alloc - len`），不足时会自动扩容，避免了缓冲区溢出的风险
- **减少内存重分配**：SDS通过**空间预分配**（扩容时多分配一些冗余空间）和**惰性空间释放**（缩短时不立即释放内存）策略，减少了内存重分配的次数
- **二进制安全**：SDS依据`len`判断字符串结束，而非`\0`，因此可以存储包含空字符的二进制数据

### 链表（LinkedList）

Redis的链表是标准的双向无环链表，每个节点都保存了指向前驱和后继节点的指针。

**结构特点**：链表结构体维护了头节点指针、尾节点指针和链表长度计数器。这使得获取链表长度、在表头表尾进行增删操作的时间复杂度都是O(1)

**应用场景**：在Redis 3.2版本之前，当列表元素较多或较大时，List类型会使用链表作为底层实现。它的优势在于节点修改效率高，但缺点是每个节点都需要独立分配内存，容易产生内存碎片，且内存开销较大（每个节点除了值，还需要两个指针）

### 压缩列表（Ziplist）& 列表包（Listpack）

压缩列表和列表包都是为了在存储少量、小尺寸数据时最大限度地节省内存而设计的紧凑型顺序结构

**压缩列表结构**：它是一块连续的内存，包含`zlbytes`（总字节数）、`zltail`（尾节点偏移量）、`zllen`（节点数量）和多个连续的`entry`（节点），最后以`zlend`标记结束。每个`entry`会记录前一个节点的长度（`prevlen`）、自身数据的编码和内容

**列表包的改进**：列表包是Redis 7.0中用来取代压缩列表的新结构。它最大的改进是**消除了压缩列表的"连锁更新"问题**。在压缩列表中，如果某个节点长度变化导致其后续所有节点的`prevlen`字段需要重新分配空间，就会引发连锁更新，性能受损。列表包通过在每个节点中记录自身长度而非前驱节点长度，完美解决了这个问题，使每个节点都独立

**应用场景**：在旧版本中，小型的Hash、List和Zset会使用压缩列表。现在，List和Hash类型在数据量小时可能会使用基于Listpack的快速列表（QuickList）

### 哈希表（Hashtable）

Redis的字典（Dict）使用哈希表作为底层实现，支持高效的键值对查找

**结构设计**：一个字典包含两个哈希表（`ht[0]`和`ht[1]`），通常只使用`ht[0]`，`ht[1]`用于Rehash（扩容或收缩时使用）。哈希表结构包含一个`dictEntry`指针数组（桶）、表大小和已用节点数。每个`dictEntry`包含键、值和指向下一个节点的指针（用于解决哈希冲突，拉链法）

**Rehash过程**：当负载因子（元素数量/桶数量）过高时，为了维持O(1)时间复杂度的查询性能，哈希表会进行扩容。这个过程是渐进式的，并非一次性完成，以避免长时间的服务器阻塞

### 整数集合（Intset）

当Set集合中的元素全是整数且数量不多时，Redis会使用整数集合来节省内存

**结构设计**：`intset`结构包含编码方式、元素数量和存储元素的连续内存数组。编码方式会根据元素大小动态升级（如从`INTSET_ENC_INT16`升级到`INTSET_ENC_INT32`），但不会降级

**升级机制**：当新加入的整数无法用当前编码表示时，整数集合会升级所有元素的编码，并重新分配内存。这样可以灵活地存储不同大小的整数，同时确保内存紧凑

### 跳跃表（Skiplist）

跳跃表是Zset（有序集合）的核心底层结构之一，它通过建立多级索引来实现平均时间复杂度为O(logN)的查找、插入和删除操作

**结构设计**：跳跃表由`zskiplist`和`zskiplistNode`组成。`zskiplist`保存了头尾节点指针、最大层数和长度。每个节点包含元素（member）、分值（score）、后退指针（指向前一个节点以实现反向遍历）以及一个`level`数组。`level`数组的每个元素代表一层，包含前进指针和跨度（记录到下一个节点的距离）

**工作原理**：高层索引形成快速通道，底层存储所有数据。查找时从最高层开始，逐步下沉，可以跳过大量不必要的比较。跳跃表与一个哈希表结合使用，哈希表用于实现O(1)复杂度的按成员取分值操作，而跳跃表负责范围查询和排序

###  快速列表（Quicklist）

从Redis 3.2开始，List类型的默认底层实现是快速列表，它是ziplist和linkedlist的混合体，旨在平衡内存使用和性能

**结构设计**：Quicklist是一个双向链表，但链表的每个节点都是一个ziplist（或在新版本中是listpack）。这样可以视为一个"由多个小块ziplist连接而成的链表"

**设计权衡**：它避免了单纯链表带来的大量内存碎片和指针开销，也避免了大型ziplist在修改时可能需要的整体重分配。通过控制每个ziplist节点的大小，取得了内存局部性和插入性能之间的良好平衡