## 5种基本数据结构

### String（字符串）

String 是 Redis 中最基本的数据类型，其值可以是字符串、整数或浮点数，且最大容量为 512MB。它是二进制安全的，意味着可以存储任何数据（如文本、图片序列化数据等）。String 支持原子操作，例如自增（`INCR`）和自减（`DECR`），适用于计数场景。

String 类型的底层编码会根据存储值的类型和长度自动选择，主要有三种实现方式：

**int 编码**：当存储的字符串值可以表示为长整型（long）时，Redis 会直接使用整数存储，以节省内存

**embstr 编码**：当存储的字符串长度**小于等于44字节**时，Redis 会使用 `embstr`格式的 SDS（Simple Dynamic String）。这种编码将 RedisObject 对象和 SDS 结构在内存中连续分配，创建和释放效率更高。

**embstr（嵌入式字符串）**：专为短字符串优化。Redis会**一次性分配一块连续的内存空间**，用于同时存储`redisObject`（对象头信息）和`sdshdr`（简单动态字符串，即实际数据）。这种方式减少了内存分配次数，内存布局紧凑，碎片更少，并且由于数据连续，能更好地利用CPU缓存，提升访问效率

**raw 编码**：当存储的字符串长度**大于44字节**时，则使用 `raw`格式的 SDS。需要注意的是，任何对 `embstr`编码字符串的修改操作，都会使其先转换为 `raw`编码，无论修改后的长度是否超过44字节。

**raw（原始字符串）**：用于存储长字符串。Redis会进行**两次独立的内存分配**，分别创建`redisObject`和`sdshdr`，然后用`redisObject`的指针指向`sdshdr`。这种方式更灵活，但内存分配开销稍大，数据在内存中不连续

**44字节**：44字节的阈值并非随意设定，而是基于精细的内存管理考量。一个`redisObject`固定占16字节。在Redis 3.2之后，SDS的头部结构被优化，用于存储短字符串的`sdshdr8`头部仅占3个字节。加上字符串内容本身和末尾的1个字节的结束符`\0`，总占用为：16字节 + 3字节 + 字符串长度 + 1字节。为了让总大小不超过常用的64字节内存分配单元，字符串长度的上限就被设定为 64 - 16 - 3 - 1 = 44字节。超过这个长度，使用单次分配大块连续内存的效益降低，因此转为`raw`编码。

### List（列表）

List 是一个双向链表结构，元素有序且可重复。支持从头部（左）或尾部（右）插入和弹出元素，操作时间复杂度为 O(1)。

**历史实现（Redis 3.2之前）**：List 的底层结构可以是 `ziplist`（压缩列表）或 `linkedlist`（双向链表）。当列表同时满足以下两个条件时，使用 `ziplist`，否则使用 `linkedlist`。

- 列表保存的**所有字符串元素的长度都小于64字节**。
- 列表保存的**元素数量少于512个**。

**当前实现（Redis 3.2及之后）**：统一采用 **`quicklist`**（快速列表）。`quicklist`是多个 `ziplist`通过双向链表连接而成的结构，结合了 `ziplist`的内存紧凑优势和 `linkedlist`的节点修改效率。

在 Redis 7.0 中，`quicklist`中的 `ziplist`节点被 `listpack`数据结构所取代，以解决 `ziplist`在极端情况下可能引发的连锁更新问题

### Hash（哈希）

Hash 是一个键值对集合，适用于存储对象（如用户信息）。每个 Hash 可以存储多达 40 多亿个键值对。

Hash 类型使用两种编码，转换条件基于存储的键值对数量和大小：

**ziplist / listpack 编码**：在 Redis 7.0 之前使用 `ziplist`，7.0 之后由 `listpack`实现。当同时满足以下两个条件时，采用此编码

- 哈希对象保存的**所有键值对的键和值的字符串长度都小于64字节**。
- 哈希对象保存的**键值对的数量小于512个**。

**hashtable 编码**：当无法同时满足上述两个条件时，编码会转换为 `hashtable`（哈希表），以保证在大数据量下的高效查询。需要注意的是，一旦转换为 `hashtable`，即使数据量减少，也不会再转回 `ziplist`或 `listpack`。

### Set（集合）

Set 是无序且不重复的字符串集合。支持交集、并集、差集等集合运算。

Set 类型的编码转换取决于元素的内容和数量：

**intset 编码**：当集合同时满足以下两个条件时，使用整数集合存储：

- 集合对象保存的**所有元素都是整数值**。
- 集合对象保存的**元素数量不超过512个**。

**hashtable 编码**：如果集合中的元素不全是整数，或者元素数量超过512个，则使用 `hashtable`编码。此时，集合的每个元素作为字典的键，值则统一为 `NULL`。

### Zset（有序集合）

Zset 是 Set 的扩展，每个元素关联一个分数（score），按分数排序。元素唯一但分数可重复。

Zset 类型的底层结构转换条件如下：

**ziplist / listpack 编码**：在 Redis 7.0 之前使用 `ziplist`，7.0 之后由 `listpack`实现。当同时满足以下两个条件时，采用此编码：

- 有序集合保存的**元素数量小于128个**。
- 有序集合保存的**所有元素的成员（member）长度都小于64字节**。

**skiplist + hashtable 编码**：当上述任一条件不满足时，则转换为组合编码。跳跃表（SkipList）负责按分值（score）维护元素的有序性，支持高效的范围查询；而哈希表（HashTable）则用于提供元素到分值的 O(1) 复杂度查找。

## 底层数据结构

### 简单动态字符串（SDS）

SDS是Redis为替代C语言原生字符串而自行实现的字符串结构，它是二进制安全的，可以存储任何数据

**结构设计**：一个SDS结构体包含三个关键字段：`len`记录已使用的字节数、`alloc`记录分配的总容量、`buf`字节数组用于保存实际字符串数据。通过在结构头中记录长度，SDS可以在O(1)时间复杂度内获取字符串长度，而C字符串需要O(N)的遍历。

**核心优势**：

- **杜绝缓冲区溢出**：在修改字符串前，SDS会检查剩余空间（`alloc - len`），不足时会自动扩容，避免了缓冲区溢出的风险
- **减少内存重分配**：SDS通过**空间预分配**（扩容时多分配一些冗余空间）和**惰性空间释放**（缩短时不立即释放内存）策略，减少了内存重分配的次数
- **二进制安全**：SDS依据`len`判断字符串结束，而非`\0`，因此可以存储包含空字符的二进制数据

### 链表（LinkedList）

Redis的链表是标准的双向无环链表，每个节点都保存了指向前驱和后继节点的指针。

**结构特点**：链表结构体维护了头节点指针、尾节点指针和链表长度计数器。这使得获取链表长度、在表头表尾进行增删操作的时间复杂度都是O(1)

**应用场景**：在Redis 3.2版本之前，当列表元素较多或较大时，List类型会使用链表作为底层实现。它的优势在于节点修改效率高，但缺点是每个节点都需要独立分配内存，容易产生内存碎片，且内存开销较大（每个节点除了值，还需要两个指针）

### 压缩列表（Ziplist）与列表包（Listpack）

压缩列表和列表包都是为了在存储少量、小尺寸数据时最大限度地节省内存而设计的紧凑型顺序结构

**压缩列表结构**：它是一块连续的内存，包含`zlbytes`（总字节数）、`zltail`（尾节点偏移量）、`zllen`（节点数量）和多个连续的`entry`（节点），最后以`zlend`标记结束。每个`entry`会记录前一个节点的长度（`prevlen`）、自身数据的编码和内容

**列表包的改进**：列表包是Redis 7.0中用来取代压缩列表的新结构。它最大的改进是**消除了压缩列表的"连锁更新"问题**。在压缩列表中，如果某个节点长度变化导致其后续所有节点的`prevlen`字段需要重新分配空间，就会引发连锁更新，性能受损。列表包通过在每个节点中记录自身长度而非前驱节点长度，完美解决了这个问题，使每个节点都独立

**应用场景**：在旧版本中，小型的Hash、List和Zset会使用压缩列表。现在，List和Hash类型在数据量小时可能会使用基于Listpack的快速列表（QuickList）

### 哈希表（Hashtable）

Redis的hashtable实现使用链地址法解决哈希冲突（同Java的HashMap），即当多个键的哈希值映射到同一数组索引（桶）时，会将这些键值对连接成一个链表（后续版本可能优化为使用跳表）

`hashtable`的实现依赖于几个关键的结构体：

```c
typedef struct dict {
    dictht ht[2]; // 两个哈希表，用于渐进式rehash
    long rehashidx; // rehash进度指示器，默认值为-1表示未进行
    // ... 其他字段（如类型特定函数等）
} dict;
```

**`dictht`(哈希表)**：`dict`结构内部包含两个 `dictht`（通常记为ht[0]和ht[1]），这是真正的存储容器

```c
typedef struct dictht {
    dictEntry **table;      // 指向桶数组的指针
    unsigned long size;     // 哈希表大小（桶的数量）
    unsigned long sizemask; // 大小掩码，用于计算索引值（总是等于size-1）
    unsigned long used;     // 当前已使用的节点数量
} dictht;
```

**`dictEntry`(哈希表节点)**：每个 `dictEntry`表示一个具体的键值对

```c
typedef struct dictEntry {
    void *key;              // 键
    union {
        void *val;          // 值（可以指向任意类型）
        uint64_t u64;
        int64_t s64;
        double d;
    } v;                    // 值（联合体，可存储指针或直接内嵌数值以节省空间）
    struct dictEntry *next; // 指向下一个节点的指针（形成链表解决哈希冲突）
} dictEntry;
```

#### 渐进式Rehash过程

当哈希表需要扩容（负载因子过高）或收缩（负载因子过低）时，Redis不会一次性将所有键值对从旧表（`ht[0]`）迁移到新表（`ht[1]`），而是采用**渐进式Rehash**策略，以避免集中式迁移导致的服务器长时间阻塞

**触发条件**：

- **扩容**：服务器没有执行BGSAVE或BGREWRITEAOF，且负载因子（`used/size`）≥1；或者负载因子≥5（强制扩容）
- **收缩**：负载因子小于0.1时

**执行步骤**：

- **分配空间**：为 `ht[1]`分配空间，大小计算为第一个大于等于 `ht[0].used * 2`（扩容）或 `ht[0].used`（收缩）的2的n次幂
- **设置rehashidx**：将字典的 `rehashidx`属性从-1设置为0，表示rehash开始
- **分批迁移**：在后续的每次对Hash的增、删、改、查命令操作中，除了执行指定操作，还会顺带将 `ht[0]`在 `rehashidx`索引上的所有键值对迁移到 `ht[1]`，然后 `rehashidx`加1
- **完成迁移**：当 `ht[0]`的所有节点都迁移完毕后，释放 `ht[0]`的空间，将 `ht[1]`设置为新的 `ht[0]`，并在 `ht[1]`处创建一个新的空白哈希表，最后将 `rehashidx`重置为-1

在渐进式rehash期间，查找、删除、更新等操作会同时在 `ht[0]`和 `ht[1]`上进行（先查旧表，再查新表）。而新增的键值对会直接存入 `ht[1]`，保证 `ht[0]`的节点数量只减不增

### 整数集合（Intset）

整数集合（intset）是Redis用于存储整数值的一种紧凑数据结构，当集合元素全是整数且数量较少时，Redis会使用intset作为集合键的底层实现，以节省内存并保持高效操作

intset的结构设计体现了Redis对内存效率的极致追求，其核心定义如下：

```c
typedef struct intset {
    uint32_t encoding;  // 编码方式
    uint32_t length;    // 元素个数
    int8_t contents[];  // 存储元素的柔性数组
} intset;
```

其中，`encoding`字段决定存储的整数类型，支持三种编码：`INTSET_ENC_INT16`（16位，2字节）、`INTSET_ENC_INT32`（32位，4字节）和`INTSET_ENC_INT64`（64位，8字节）。`length`表示当前集合中元素的数量，而`contents`数组则实际存储元素数据，其中的元素按照升序排列且保证唯一性。

#### 类型升级机制

intset最独特的特性是其自动升级机制。当插入的新元素值超出当前编码所能表示的范围时，intset会进行升级操作

升级过程分为三个步骤：

1. **空间分配**：根据新编码计算所需内存空间，并重新分配
2. **元素迁移**：将现有元素从后向前转换为新编码，放置到正确位置
3. **插入新元素**：将新元素添加到适当位置（开头或末尾）

例如，一个原本存储`[1, 3, 5]`（使用16位编码）的intset，当插入一个超过32767的大数（如50000）时，会升级到32位编码，然后插入新元素。升级过程确保了数据的有序性得以维持，并且**一旦升级，不支持降级**

#### 核心操作原理

##### 查找操作

intset使用二分查找算法来定位元素，时间复杂度为O(log n)。查找过程首先检查集合是否为空，然后判断目标值是否在集合的数值范围内，最后进行二分查找。

##### 插入操作

插入新元素时，intset会执行以下流程

1. 判断新元素的编码需求，如需升级则调用升级流程
2. 使用二分查找确定插入位置，确保元素有序性和唯一性
3. 扩容并移动后续元素，插入新值

##### 删除操作

删除元素同样需要移动后续元素以填充空隙，保持内存连续性

### 跳跃表（Skiplist）

跳跃表是Zset（有序集合）的核心底层结构之一，它通过建立多级索引来实现平均时间复杂度为O(logN)的查找、插入和删除操作

**结构设计**：跳跃表由`zskiplist`和`zskiplistNode`组成。`zskiplist`保存了头尾节点指针、最大层数和长度。每个节点包含元素（member）、分值（score）、后退指针（指向前一个节点以实现反向遍历）以及一个`level`数组。`level`数组的每个元素代表一层，包含前进指针和跨度（记录到下一个节点的距离）

**工作原理**：高层索引形成快速通道，底层存储所有数据。查找时从最高层开始，逐步下沉，可以跳过大量不必要的比较。跳跃表与一个哈希表结合使用，哈希表用于实现O(1)复杂度的按成员取分值操作，而跳跃表负责范围查询和排序

###  快速列表（Quicklist）

从Redis 3.2开始，List类型的默认底层实现是快速列表，它是ziplist和linkedlist的混合体，旨在平衡内存使用和性能

**结构设计**：Quicklist是一个双向链表，但链表的每个节点都是一个ziplist（或在新版本中是listpack）。这样可以视为一个"由多个小块ziplist连接而成的链表"

**设计权衡**：它避免了单纯链表带来的大量内存碎片和指针开销，也避免了大型ziplist在修改时可能需要的整体重分配。通过控制每个ziplist节点的大小，取得了内存局部性和插入性能之间的良好平衡