## 内存淘汰

当 Redis 的内存使用量达到上限时，就需要通过**淘汰策略**来清理部分数据，以腾出空间存储新数据。

配置文件设置最大内存：

```
# 最大内存
maxmemory <size>

例如
maxmemory 8gb
```

配置文件指定淘汰策略：

```
maxmemory-policy <policy>

例如
maxmemory-policy noeviction
```

如果淘汰策略使用了采样算法，配置文件中可配置采样大小：

```
maxmemory-samples <size>

例如
maxmemory-samples 5
```

也可以在运行时动态设置采样大小：

```
CONFIG SET maxmemory-samples <size>

例如
CONFIG SET maxmemory-samples 5
```

查看当前采样大小：

```
CONFIG GET maxmemory-samples
```



| 策略名          | 作用                                                         |
| --------------- | ------------------------------------------------------------ |
| noeviction      | 不淘汰，内存不够触发报错。                                   |
| allkeys-lru     | 所有键中采样一批键，lru权重最低的淘汰（淘汰1个key）；再检查内存是否超出，如超出重复触发淘汰。 |
| allkeys-lfu     | 所有键中采样一批键，lfu权重低的淘汰（淘汰1个key）；再检查内存是否超出，如超出重复触发淘汰。 |
| allkeys-random  | 所有键都可能被随机淘汰，随机抽1个key淘汰；再检查内存是否超出，如超出重复触发淘汰。 |
| volatile-lru    | 有设置过期的键中采样一批键，lru权重低的淘汰（淘汰1个key）；再检查内存是否超出，如超出重复触发淘汰。 |
| volatile-lfu    | 有设置过期的键中采样一批键，lfu权重低的淘汰（淘汰1个key）；再检查内存是否超出，如超出重复触发淘汰。 |
| volatile-random | 有设置过期的键可能被随机淘汰，随机抽1个key淘汰；再检查内存是否超出，如超出重复触发淘汰。 |
| volatile-ttl    | 有设置过期的键中采样一批键，优先淘汰其中快过期的键。         |



## LRU

最近最少使用：淘汰**最久未访问**的数据

使用过程：

1. Redis对象（`redisObject`）有一个24位的lru字段记录最后一次访问的时间戳。
2. 抽样一组key，对比时间戳，最久为访问的淘汰。



**优点**

1. 实现相对简单。
2. 对短期热点key友好。

**缺点**

1. 容易误删长期热点key。



## LFU 

最不经常使用：淘汰**访问频率最低**的数据

使用过程

1. 将Redis对象（`redisObject`）的lru字段分为两部分：高16位记录最后一次访问的时间戳（分钟级）；低8位记录访问频率计数器。
2. 抽样一组key，对比计数器，最小的淘汰。



### 计数器概率+1

LFU中的计数器并不是访问一次就 +1，而是概率+1，递增曲线类似于对数函数。

**优点**

计数器仅0-255的大小区间，防止递增过快。

**流程**

当key被访问一次，进行计数器+1逻辑：

1. count = 计数器当前值

2. a = 0～1随机数
3. b = 1 / （count + lfu-log-factor配置值）
4. 如果 a < b，count + 1；否则，不加。



### 计数器衰减

key在一段时间内不被访问，LFU的计数器会进行衰减。

**优点**

旧热点key也会被回收。

**流程**

根据衰减时间配置：

```
lfu-decay-time 1   # 单位：分钟
```

计算需要衰减的值 = （当前时间 - 上次访问衰减） / 衰减时间配置

淘汰时会拿到衰减后的counter进行比较



## 候选池（eviction pool）

LRU、LFU、volatile-ttl都使用了候选池机制，缓存了最可能被淘汰的key，避免每删一个key就重新随机采样。

**候选池默认16，重新采样阈值25%，不可修改。**



### 执行机制

1. 第一次触发内存淘汰（used_memory > maxmemory），触发第一次refill（ 0 - 16），将候选池填满。
2. 每次淘汰1个key，淘汰4次后，淘汰了25%，触发一次refill，补充候选池。



### 优点

1. 连续触发时不会频繁取样。
2. 空间置换时间。



