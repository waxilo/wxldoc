## HTTP

### 版本比较

| 特性维度      | HTTP/0.9 | HTTP/1.0 | HTTP/1.1     | HTTP/2            | HTTP/3              |
| --------- | -------- | -------- | ------------ | ----------------- | ------------------- |
| **诞生年份**  | 1991     | 1996     | 1999         | 2015              | 2022 (正式标准)         |
| **协议基础**  | TCP      | TCP      | TCP          | TCP               | **QUIC (基于UDP)**    |
| **连接模型**  | 短连接      | 短连接      | **持久连接、管道化** | **多路复用**          | 多路复用                |
| **头部数据**  | 无        | 文本       | 文本           | **二进制分帧，HPACK压缩** | 二进制，QPACK压缩         |
| **服务器推送** | 不支持      | 不支持      | 不支持          | **支持**            | 支持                  |
| **关键问题**  | 功能极其有限   | 连接开销大    | 队头阻塞         | TCP层队头阻塞          | 从底层解决队头阻塞           |
| **安全性**   | 无        | 无        | 无            | 主流需配合HTTPS        | **内建加密 (TLS 1.3+)** |

### HTTP/0.9 - 远古时代

- **极度简单**：只有一个 `GET`方法。
- **无协议头**：请求和响应都没有头部信息。
- **响应即内容**：服务器直接返回 HTML 内容，之后立即关闭 TCP 连接。
- **无状态码**：如果出错，返回一个特殊的 HTML 文档给用户看。

### HTTP/1.0 - 搭建框架

- **引入协议头**：在请求和响应中增加了 Header 概念，传递元数据（如状态码、内容类型、编码等）。
- **更多方法**：引入了 `POST`, `HEAD`方法。
- **支持多格式**：不再限于 HTML，可以传输图片、视频等。
- **主要缺陷**：**每个 TCP 连接只处理一个请求**。对于有多个资源（图片、CSS、JS）的现代网页，频繁建立和断开 TCP 连接的成本极高。

### HTTP/1.1 - 标准基石

这是使用时间最长、最经典的版本，解决了 1.0 的核心性能问题。

- **持久连接**：引入了 `Connection: keep-alive`。一个 TCP 连接可以处理多个请求/响应，显著减少了连接开销。
- **管道化**：允许客户端在同一连接上连续发送多个请求，而无需等待响应。但存在**队头阻塞**问题：如果第一个请求处理慢，会阻塞后续所有请求的响应。
- **更多功能**：增加了 `PUT`, `DELETE`, `OPTIONS`等方法；引入了 `Host`头，支持虚拟主机。
- **缓存强化**：引入了更精细的缓存控制策略，如 `ETag`, `Cache-Control`。
- **核心问题**：**队头阻塞** 和 **头部冗余**（每次通信都携带冗长的文本头部）。

### HTTP/2 - 现代高性能

HTTP/2 专注于性能优化，完全兼容 HTTP/1.1 的语义（方法、状态码、头字段等）。

- **二进制协议**：不再使用纯文本，而是采用二进制帧进行通信，解析更高效，错误更少。
- **多路复用**：这是**核心特性**。在同一个 TCP 连接上，可以并行交错地发送多个请求和响应，彻底解决了 HTTP/1.1 的队头阻塞问题。
- **头部压缩**：使用 **HPACK** 算法压缩请求头和响应头，大大减少了冗余数据。
- **服务器推送**：服务器可以“预测”客户端需要的资源，在客户端请求之前主动推送过去（例如，当客户端请求 HTML 时，服务器主动推送相关的 CSS 和 JS 文件）。
- **遗留问题**：虽然解决了应用层的队头阻塞，但 **TCP 层的队头阻塞** 依然存在。即 TCP 连接中一个丢失的数据包会导致所有流（Stream）等待重传。

### HTTP/3 - 面向未来

HTTP/3 是一次彻底的革新，旨在解决 HTTP/2 的遗留问题。

- **将传输层从 TCP 改为 QUIC**：QUIC 是基于 UDP 的全新协议。
- **解决 TCP 队头阻塞**：QUIC 在用户态实现了自己的连接管理和数据重传机制。每个流是独立的，一个流的数据包丢失只会影响该流，其他流不受影响。
- **内建安全**：加密（使用 TLS 1.3）是 QUIC 协议不可或缺的一部分，连接建立更快。
- **更快的连接建立**：QUIC 的握手通常只需要 0-RTT 或 1-RTT，比 TCP + TLS 更快，尤其对移动网络友好。
- **继承 HTTP/2 优点**：天然具备多路复用、头部压缩等特性。

### 总结与比喻

- **HTTP/1.1** 就像一条**单行道**，虽然有多个车道（持久连接），但每辆车（请求）必须按顺序到达目的地。前面有车抛锚（队头阻塞），后面的全得等着。
- **HTTP/2** 将单行道升级为**全立交高速公路**。所有车辆（请求/响应流）可以在多条车道上并行飞驰（多路复用），互不干扰。但这条路建在 TCP 地基上，一旦地基有一处塌陷（丢包），整条路的所有车道都要暂停维修。
- **HTTP/3** 不仅建了立交桥，还彻底**更换了更先进的地基（QUIC）**。当地基某处出现问题，只会封闭那一条车道进行维修，其他车道照常通行。

### **现状与选择**

- **HTTP/1.1**：仍在大量使用，是互联网的基石。
- **HTTP/2**：当前的主流和标配，绝大多数现代网站和浏览器都已支持。
- **HTTP/3**：是未来的方向，正在被快速采用（Cloudflare, Google, Facebook 等已大规模部署），浏览器支持也越来越好。

## 三次握手

<img src="/三次握手.png" alt="16bb3a896d732" style="zoom: 50%;" />

### 衍生问题

**为什么是三次，而不是两次？**

**核心原因：防止已失效的连接请求报文突然传到服务器，导致资源浪费和错误。**
想象一个场景：客户端发送了一个连接请求（第一次握手），但由于网络拥堵，这个请求迟迟没到服务器。客户端超时后重发了一个新请求并正常完成了通信，关闭了连接。此时，那个失效的旧请求终于到达了服务器。如果只有两次握手，服务器会认为这是一个新的连接请求，直接进入 `ESTABLISHED`状态并等待客户端发送数据，但客户端早已关闭，这会导致服务器资源被白白占用。**第三次握手是一个“确认的确认”，它让客户端来最终拍板，只有客户端允许的连接才能真正建立。**

## 四次挥手



<img src="/四次挥手.png" alt="3d4952f3b9521" style="zoom:50%;" />

### 衍生问题

**为什么是四次挥手？**

因为 TCP 是全双工的，并且可能存在"半关闭"状态。第二次挥手和第三次挥手**不能合并**。服务器在收到客户端的 FIN 后，它可能还有数据需要发送，所以它先回复一个 ACK 确认，等所有数据都发送完毕后，再单独发送一个 FIN 报文来关闭自己这个方向的连接。

**为什么主动关闭方需要 `TIME-WAIT`状态？等待 2MSL 是为了什么？**

**可靠地终止连接**：确保最后一次 ACK（第四次挥手）能到达服务器。如果这个 ACK 丢失，服务器会超时重传它的 FIN（第三次挥手），客户端在 `TIME-WAIT`状态下还能收到并重发 ACK。

**让旧连接的报文在网络中消逝**：防止之前延迟的、属于这个连接的报文段被之后新建的、具有相同四元组（源IP、源端口、目的IP、目的端口）的连接错误地接收。

**MSL是什么意思?**

**Maximum Segment Lifetime**（报文段最大生存时间）